// color.mind - Color Palettes and Conversions for Fractal Voyager
//
// Colors are represented as tensors:
//   - RGB: Tensor<f32, [3]> with components in [0, 1]
//   - RGBA: Tensor<f32, [4]> with alpha channel
//   - Image: Tensor<f32, [H, W, 3]> or [H, W, 4]
//
// All operations use MIND's tensor semantics with broadcasting.
//
// Author: STARGA Inc. <noreply@star.ga>
// License: MIT
// Specification reference: spec/v1.0/language.md

import tensor::zeros;
import tensor::ones;
import math::sin;
import math::cos;
import math::sqrt;
import math::floor;
import math::fract;
import math::abs;
import math::clamp;
import math::min;
import math::max;
import math::log;

// =============================================================================
// Color Constants
// =============================================================================

// Black color [0, 0, 0]
fn color_black() -> Tensor<f32, [3]> {
    zeros([3])
}

// White color [1, 1, 1]
fn color_white() -> Tensor<f32, [3]> {
    ones([3])
}

// Red color [1, 0, 0]
fn color_red() -> Tensor<f32, [3]> {
    [1.0, 0.0, 0.0]
}

// Green color [0, 1, 0]
fn color_green() -> Tensor<f32, [3]> {
    [0.0, 1.0, 0.0]
}

// Blue color [0, 0, 1]
fn color_blue() -> Tensor<f32, [3]> {
    [0.0, 0.0, 1.0]
}

// =============================================================================
// Color Space Conversion
// =============================================================================

// Convert HSV to RGB
// Input: Tensor<f32, [3]> with H in [0,1], S in [0,1], V in [0,1]
// Output: Tensor<f32, [3]> RGB
fn hsv_to_rgb(hsv: Tensor<f32, [3]>) -> Tensor<f32, [3]> {
    let h = hsv[0];
    let s = hsv[1];
    let v = hsv[2];

    let c = v * s;
    let h6 = h * 6.0;
    let x = c * (1.0 - abs(fract(h6 / 2.0) * 2.0 - 1.0));
    let m = v - c;

    let hi = floor(h6) % 6.0;

    // Use conditional tensor operations
    let r = select(hi < 1.0, c,
            select(hi < 2.0, x,
            select(hi < 3.0, 0.0,
            select(hi < 4.0, 0.0,
            select(hi < 5.0, x, c)))));

    let g = select(hi < 1.0, x,
            select(hi < 2.0, c,
            select(hi < 3.0, c,
            select(hi < 4.0, x,
            select(hi < 5.0, 0.0, 0.0)))));

    let b = select(hi < 1.0, 0.0,
            select(hi < 2.0, 0.0,
            select(hi < 3.0, x,
            select(hi < 4.0, c,
            select(hi < 5.0, c, x)))));

    [r + m, g + m, b + m]
}

// Batched HSV to RGB for image processing
// Input: Tensor<f32, [H, W, 3]> HSV image
// Output: Tensor<f32, [H, W, 3]> RGB image
fn hsv_to_rgb_image(hsv: Tensor<f32, [H, W, 3]>) -> Tensor<f32, [H, W, 3]> {
    let h = hsv[:, :, 0];  // Shape [H, W]
    let s = hsv[:, :, 1];
    let v = hsv[:, :, 2];

    let c = v * s;
    let h6 = h * 6.0;
    let x = c * (1.0 - abs(fract(h6 / 2.0) * 2.0 - 1.0));
    let m = v - c;

    let hi = floor(h6) % 6.0;

    // Vectorized selection across entire image
    let r = select(hi < 1.0, c,
            select(hi < 2.0, x,
            select(hi < 3.0, zeros([H, W]),
            select(hi < 4.0, zeros([H, W]),
            select(hi < 5.0, x, c)))));

    let g = select(hi < 1.0, x,
            select(hi < 2.0, c,
            select(hi < 3.0, c,
            select(hi < 4.0, x,
            select(hi < 5.0, zeros([H, W]), zeros([H, W]))))));

    let b = select(hi < 1.0, zeros([H, W]),
            select(hi < 2.0, zeros([H, W]),
            select(hi < 3.0, x,
            select(hi < 4.0, c,
            select(hi < 5.0, c, x)))));

    stack([r + m, g + m, b + m], axis=2)
}

// =============================================================================
// Color Arithmetic
// =============================================================================

// Scale color by scalar
fn color_scale(c: Tensor<f32, [3]>, t: f32) -> Tensor<f32, [3]> {
    c * t
}

// Add two colors
fn color_add(a: Tensor<f32, [3]>, b: Tensor<f32, [3]>) -> Tensor<f32, [3]> {
    a + b
}

// Linear interpolation between colors
fn color_lerp(a: Tensor<f32, [3]>, b: Tensor<f32, [3]>, t: f32) -> Tensor<f32, [3]> {
    a + (b - a) * t
}

// Clamp color to [0, 1] range
fn color_clamp(c: Tensor<f32, [3]>) -> Tensor<f32, [3]> {
    clamp(c, 0.0, 1.0)
}

// =============================================================================
// Fractal Color Palettes
// =============================================================================

// Color scheme enumeration (using integer codes)
// 0 = Electric, 1 = Fire, 2 = Ocean, 3 = Neon
// 4 = Grayscale, 5 = Psychedelic, 6 = Plasma, 7 = Galaxy

// Electric rainbow palette
fn palette_electric(t: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let h = fract(t * 5.0 + time * 0.1 + audio * 2.0);
    let s = 0.8 + audio * 0.2;
    let v = 0.9;
    hsv_to_rgb([h, s, v])
}

// Fire gradient (black -> red -> yellow -> white)
fn palette_fire(t: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let r = min(1.0, t * 3.0);
    let g = max(0.0, min(1.0, (t - 0.33) * 3.0)) * 0.6;
    let b = max(0.0, (t - 0.66) * 3.0) * 0.2;
    [r, g, b] * (1.0 + audio)
}

// Ocean blues and teals
fn palette_ocean(t: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let b = 0.4 + t * 0.6;
    let g = t * 0.6 + audio * 0.3;
    let r = t * 0.3;
    [r, g, b]
}

// Neon sinusoidal colors
fn palette_neon(t: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let pi = 3.14159265359;
    let phase = t * pi * 4.0 + time * 0.1 + audio * 2.0;
    let r = 0.5 + 0.5 * sin(phase);
    let g = 0.5 + 0.5 * sin(phase + 2.094);
    let b = 0.5 + 0.5 * sin(phase + 4.188);
    [r, g, b] * (1.0 + audio * 0.5)
}

// Grayscale
fn palette_grayscale(t: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let v = sqrt(t);
    [v, v, v]
}

// High-frequency psychedelic
fn palette_psychedelic(t: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let h = fract(t * 10.0 + time * 0.1 + audio * 2.0);
    let s = 0.7 + 0.3 * sin(t * 20.0 + audio * 10.0);
    hsv_to_rgb([h, s, 1.0])
}

// Plasma interference pattern
fn palette_plasma(t: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let pi = 3.14159265359;
    let time_offset = time * 0.1 + audio * 2.0;
    let x = sin(t * 2.0 * pi + time_offset) * 0.5 + 0.5;
    let y = cos(t * 3.0 * pi + time_offset * 0.7) * 0.5 + 0.5;
    [x, y * 0.5 + 0.5 * x, 1.0 - x * y] * (1.0 + audio * 0.3)
}

// Galaxy with star sparkles
fn palette_galaxy(t: f32, iter: f32, time: f32, audio: f32) -> Tensor<f32, [3]> {
    let h = fract(t * 2.0 + 0.7);
    let s = 0.6 + 0.4 * sin(t * 10.0);
    let v = 0.3 + t * 0.7;
    let base = hsv_to_rgb([h, s, v]);

    // Add star sparkles using pseudo-random noise
    let star_noise = fract(sin(iter * 12.9898 + t * 100.0 * 78.233) * 43758.5453);
    let sparkle = select(star_noise > 0.98, 1.0 + audio, 0.0);

    base + [sparkle, sparkle, sparkle]
}

// =============================================================================
// Unified Palette Function
// =============================================================================

// Get color for normalized iteration value
// scheme: 0-7 for different palettes
// t: normalized iteration (0 to 1)
// iter: raw iteration count (for noise-based effects)
// time: animation time
// audio: audio intensity [0, 1]
fn get_palette_color(
    scheme: i32,
    t: f32,
    iter: f32,
    time: f32,
    audio: f32
) -> Tensor<f32, [3]> {
    select(scheme == 0, palette_electric(t, time, audio),
    select(scheme == 1, palette_fire(t, time, audio),
    select(scheme == 2, palette_ocean(t, time, audio),
    select(scheme == 3, palette_neon(t, time, audio),
    select(scheme == 4, palette_grayscale(t, time, audio),
    select(scheme == 5, palette_psychedelic(t, time, audio),
    select(scheme == 6, palette_plasma(t, time, audio),
           palette_galaxy(t, iter, time, audio))))))))
}

// =============================================================================
// Image Color Operations
// =============================================================================

// Apply color palette to iteration counts image
// iterations: Tensor<f32, [H, W]> - smooth iteration counts
// max_iter: maximum iterations (for normalization)
// scheme: color scheme index
// time: animation time
// audio: audio intensity
fn colorize_iterations(
    iterations: Tensor<f32, [H, W]>,
    max_iter: f32,
    scheme: i32,
    time: f32,
    audio: f32
) -> Tensor<f32, [H, W, 3]> {
    // Normalize iterations to [0, 1]
    let t = iterations / max_iter;

    // Check for points in set (max iterations reached)
    let in_set = iterations >= max_iter;

    // Compute color for each pixel (vectorized)
    // This generates H*W color values
    let h = fract(t * 5.0 + time * 0.1 + audio * 2.0);
    let s = 0.8 + audio * 0.2;
    let v = 0.9;

    // Build HSV image
    let hsv = stack([h, s * ones([H, W]), v * ones([H, W])], axis=2);
    let rgb = hsv_to_rgb_image(hsv);

    // Black out points in set
    let mask = expand_dims(1.0 - cast(in_set, f32), axis=2);  // [H, W, 1]
    rgb * mask  // Broadcasting: [H, W, 3] * [H, W, 1]
}
